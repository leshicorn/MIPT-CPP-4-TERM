Мы написали класс TripManager для бронирования набора перелётов и отелей, использующий
вспомогательные классы FlightProvider и HotelProvider. Следуя идиоме RAII, мы вынесли заброниро-
ванный набор в отдельный класс Trip. Написанный код мы немного модифицировали и поместили в
файлы old_booking_providers.h и old_trip_manager.h
Вам теперь предлагается сделать так, чтобы отдельные бронирования перелёта и отеля тоже
были оформлены в духе RAII. Это позволит упростить класс Trip: в его функции Cancel не придётся
вызывать отмены бронирований, а достаточно будет просто удалить элементы из векторов.
Вам даны новые версии классов TripManager, Trip, FlightProvider и HotelProvider, которые лежат
в файлах new_booking_providers.h и new_trip_manager.h. Функцию Cancel в новых классах мы пере-
именовали в CancelOrComplete: она должна будет автоматически вызываться не только при отмене
бронирования, но и при успешном его завершении. Теперь функции Book и CancelOrComplete в клас-
сах-провайдерах возвращают и принимают не BookingId, а специальный класс, который вам и нужно
создать.
Так как FlightProvider и HotelProvider имеют одинаковый интерфейс, то, чтобы избежать дубли-
рования кода, мы просим вас разработать шаблонный класс Booking<Provider>, где в качестве шаб-
лонного типа будут выступать FlightProvider и HotelProvider.
Пришлите в тестирующую систему файл new_booking_providers.h, который:
•
•
содержит пространство имён RAII
внутри пространства имён RAII содержит определение шаблонного класса Booking<Provider>
Интерфейс класса Booking<Provider> должен стать вам понятен после изучения файлов
new_booking_providers.h и new_trip_manager.h.
Для удобства тестирования мы сделали счётчик бронирований и максимально допустимое ко-
личество бронирований публичными статическими переменными классов FlightProvider и
HotelProvider.

new_booking_providers.h:
#pragma once

// Здесь будет подключён ваш файл с определением шаблонного класса Booking в пространстве имён RAII
#include "booking.h"

#include <stdexcept>
#include <string>

using namespace std;

class FlightProvider {
public:
  using BookingId = int;
  using Booking = RAII::Booking<FlightProvider>;
  friend Booking;  // Явно разрешаем функциям класса Booking вызывать private-функции нашего класса FlightProvider

  struct BookingData {
    string city_from;
    string city_to;
    string date;
  };

  Booking Book(const BookingData& data) {
    if (counter >= capacity) {
      throw runtime_error("Flight overbooking");
    }
    ++counter;
    return {this, counter};
  }

private:
  // Скрываем эту функцию в private, чтобы её мог позвать только соответствующий friend-класс Booking
  void CancelOrComplete(const Booking& booking) {
    --counter;
  }

public:
  static int capacity;
  static int counter;
};


class HotelProvider {
public:
  using BookingId = int;
  using Booking = RAII::Booking<HotelProvider>;
  friend Booking;

  struct BookingData {
    string city;
    string date_from;
    string date_to;
  };

  Booking Book(const BookingData& data) {
    if (counter >= capacity) {
      throw runtime_error("Hotel overbooking");
    }
    ++counter;
    return {this, counter};
  }

private:
  void CancelOrComplete(const Booking& booking) {
    --counter;
  }

public:
  static int capacity;
  static int counter;
};


new_trip_manager:
#include "new_booking_providers.h"

#include <vector>

using namespace std;

class Trip {
public:
  vector<HotelProvider::Booking> hotels;
  vector<FlightProvider::Booking> flights;

  Trip() = default;
  Trip(const Trip&) = delete;
  Trip(Trip&&) = default;

  Trip& operator=(const Trip&) = delete;
  Trip& operator=(Trip&&) = default;

  void Cancel() {
    hotels.clear();
    flights.clear();
  }
};


class TripManager {
public:
  struct BookingData {
    string city_from;
    string city_to;
    string date_from;
    string date_to;
  };

  Trip Book(const BookingData& data) {
    Trip trip;
    {
      FlightProvider::BookingData data;
      trip.flights.push_back(flight_provider.Book(data));
    }
    {
      HotelProvider::BookingData data;
      trip.hotels.push_back(hotel_provider.Book(data));
    }
    {
      FlightProvider::BookingData data;
      trip.flights.push_back(flight_provider.Book(data));
    }
    return trip;
  }

  void Cancel(Trip& trip) {
    trip.Cancel();
  }

private:
  HotelProvider hotel_provider;
  FlightProvider flight_provider;
};


old_booking_providers:
#pragma once

#include <stdexcept>
#include <string>

using namespace std;

class FlightProvider {
public:
  using BookingId = int;

  struct BookingData {
    string city_from;
    string city_to;
    string date;
  };

  BookingId Book(const BookingData& data) {
    if (counter >= capacity) {
      throw runtime_error("Flight overbooking");
    }
    ++counter;
    return counter;
  }

  void Cancel(const BookingId& id) {
    --counter;
    if (counter < 0) {
      throw logic_error("Too many flights have been canceled");
    }
  }

public:
  static int capacity;
  static int counter;
};


class HotelProvider {
public:
  using BookingId = int;

  struct BookingData {
    string city;
    string date_from;
    string date_to;
  };

  BookingId Book(const BookingData& data) {
    if (counter >= capacity) {
      throw runtime_error("Hotel overbooking");
    }
    ++counter;
    return counter;
  }

  void Cancel(const BookingId& id) {
    --counter;
    if (counter < 0) {
      throw logic_error("Too many hotels have been canceled");
    }
  }

public:
  static int capacity;
  static int counter;
};

old_trip_manager:
#include "old_booking_providers.h"

#include <vector>

using namespace std;

class Trip {
private:
  HotelProvider& hotel_provider;
  FlightProvider& flight_provider;

public:
  vector<HotelProvider::BookingId> hotels;
  vector<FlightProvider::BookingId> flights;

  Trip(HotelProvider& hp, FlightProvider& fp)
      : hotel_provider(hp),
        flight_provider(fp)
  {
  }

  Trip(const Trip&) = delete;
  Trip(Trip&&) = default;

  Trip& operator=(const Trip&) = delete;
  Trip& operator=(Trip&&) = default;

  void Cancel() {
    for (auto& id : hotels) {
      hotel_provider.Cancel(id);
    }
    hotels.clear();
    for (auto& id : flights) {
      flight_provider.Cancel(id);
    }
    flights.clear();
  }

  ~Trip() {
    Cancel();
  }

};


class TripManager {
public:
  struct BookingData {
    string city_from;
    string city_to;
    string date_from;
    string date_to;
  };

  Trip Book(const BookingData& data) {
    Trip trip(hotel_provider, flight_provider);
    {
      FlightProvider::BookingData data;
      trip.flights.push_back(flight_provider.Book(data));
    }
    {
      HotelProvider::BookingData data;
      trip.hotels.push_back(hotel_provider.Book(data));
    }
    {
      FlightProvider::BookingData data;
      trip.flights.push_back(flight_provider.Book(data));
    }
    return trip;
  }

  void Cancel(Trip& trip) {
    trip.Cancel();
  }

private:
  HotelProvider hotel_provider;
  FlightProvider flight_provider;
};













#pragma once

namespace RAII {

template <typename Provider>
class Booking {
public:
    // Конструктор
    Booking(Provider* provider, int id)
        : provider_(provider), id_(id), active_(true) {}

    // Конструктор перемещения
    Booking(Booking&& other) noexcept
        : provider_(other.provider_), id_(other.id_), active_(other.active_) {
        other.active_ = false; // Перемещенный объект неактивен
    }

    // Оператор перемещения
    Booking& operator=(Booking&& other) noexcept {
        if (this != &other) {
            if (active_) {
                provider_->CancelOrComplete(*this);
            }
            provider_ = other.provider_;
            id_ = other.id_;
            active_ = other.active_;
            other.active_ = false; // Перемещенный объект неактивен
        }
        return *this;
    }

    // Деструктор
    ~Booking() {
        if (active_) {
            provider_->CancelOrComplete(*this);
        }
    }

    // Получение ID бронирования
    int GetId() const {
        return id_;
    }

private:
    Provider* provider_; // Указатель на провайдера, для которого было сделано бронирование
    int id_;             // ID бронирования
    bool active_;        // Активен ли объект бронирования

    // Запрещаем копирование
    Booking(const Booking&) = delete;
    Booking& operator=(const Booking&) = delete;
};

} // namespace RAII

