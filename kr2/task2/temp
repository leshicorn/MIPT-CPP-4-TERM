В этой задаче мы воспользуемся умным указателем unique_ptr для управления временем
жизни дерева полиморфных объектов. А конкретнее, будем работать с деревом арифметического вы-
ражения. Узлами дерева будут числа и операции.
Например, выражение "2*(3+4)" будет представлено вот таким деревом:
*
| \
2  +
  / \
 3   4

В программе узлы дерева представляются объектами типов, унаследованных от интерфейса
Expression, который объявлен в файле Common.h. У интерфейса есть два метода:
• Evaluate() возвращает численное значение выражения. Для нашего примера это будет 14.
• ToString() форматирует выражение как строку. Для простоты реализации, чтобы не учитывать
приоритеты операций, каждый узел берётся в скобки. То есть для нашего примера этот метод
вернёт "(2)*((3)+(4))".

Так как Expression — это абстрактный класс, работать с ним можно только через указатель или
ссылку. Чтобы не заниматься ручным управлением памятью, будем использовать умный указатель
unique_ptr. Чтобы не загромождать код выражениями unique_ptr<Expression>, в файле Common.h для
этого выражения предоставлен синоним ExpressionPtr.
Реализуйте функции, которые позволяют создавать такое дерево выражения. Они объявлены
в файле Common.h, который приведён ниже:

Value() возвращает дерево из одного узла, представляющего целое число.
Sum() возвращает новое дерево, которое представляет сумму двух переданных выражений.
Product() возвращает новое дерево, которое представляет произведение двух переданных
выражений.
Таким образом, следующий код создаст дерево для выражения "2*(3+4)":

Product(Value(2), Sum(Value(3), Value(4)));

#include <memory>
#include <string>

// Базовый класс арифметического выражения
class Expression {
    public: virtual~Expression() =
        default;

    // Вычисляет значение выражения
    virtual int Evaluate() const = 0;

    // Форматирует выражение как строку
    // Каждый узел берётся в скобки, независимо от приоритета
    virtual std::string ToString() const = 0;
};

using ExpressionPtr = std::unique_ptr < Expression > ;

// Функции для формирования выражения
ExpressionPtr Value(int value);
ExpressionPtr Sum(ExpressionPtr left, ExpressionPtr right);
ExpressionPtr Product(ExpressionPtr left, ExpressionPtr right);

#include "Common.h"
#include <sstream>
using namespace std;

// Функция для проверки 
bool check_equal(string value1, string value2) {

}

string Print(const Expression * e) {
    if (!e) {
        return "Null expression provided";
    }
    stringstream output;
    output << e -> ToString() << " = " << e -> Evaluate();
    return output.str();
}

void Test() {
    ExpressionPtr e1 = Product(Value(2), Sum(Value(3), Value(4)));
    if !check_equal(Print(e1.get()), "(2)*((3)+(4)) = 14") {
        cout << "Error\n";
    }

    ExpressionPtr e2 = Sum(move(e1), Value(5));
    if !check_equal(Print(e2.get()), "((2)*((3)+(4)))+(5) = 19"){
        cout << "Error\n";
    }

    if !check_equal(Print(e1.get()), "Null expression provided"){
        cout << "Error\n";
    }
}

int main() {
    TestRunner tr;
    RUN_TEST(tr, Test);
    return 0;
}




// Common.h

#pragma once

#include <memory>
#include <string>

// Базовый класс арифметического выражения
class Expression {
public:
    virtual ~Expression() = default;

    // Вычисляет значение выражения
    virtual int Evaluate() const = 0;

    // Форматирует выражение как строку
    // Каждый узел берётся в скобки, независимо от приоритета
    virtual std::string ToString() const = 0;
};

using ExpressionPtr = std::unique_ptr<Expression>;

// Функции для формирования выражения
ExpressionPtr Value(int value);
ExpressionPtr Sum(ExpressionPtr left, ExpressionPtr right);
ExpressionPtr Product(ExpressionPtr left, ExpressionPtr right);




// main.cpp

#include "Common.h"
#include <sstream>
#include <iostream>
#include <cassert>
using namespace std;

// Класс для представления числового значения
class ValueNode : public Expression {
public:
    explicit ValueNode(int value) : value_(value) {}

    int Evaluate() const override {
        return value_;
    }

    std::string ToString() const override {
        return std::to_string(value_);
    }

private:
    int value_;
};

// Класс для представления операции суммы
class SumNode : public Expression {
public:
    SumNode(ExpressionPtr left, ExpressionPtr right)
        : left_(move(left)), right_(move(right)) {}

    int Evaluate() const override {
        return left_->Evaluate() + right_->Evaluate();
    }

    std::string ToString() const override {
        return "(" + left_->ToString() + ")+(" + right_->ToString() + ")";
    }

private:
    ExpressionPtr left_, right_;
};

// Класс для представления операции произведения
class ProductNode : public Expression {
public:
    ProductNode(ExpressionPtr left, ExpressionPtr right)
        : left_(move(left)), right_(move(right)) {}

    int Evaluate() const override {
        return left_->Evaluate() * right_->Evaluate();
    }

    std::string ToString() const override {
        return "(" + left_->ToString() + ")*(" + right_->ToString() + ")";
    }

private:
    ExpressionPtr left_, right_;
};

// Реализация функций создания узлов дерева
ExpressionPtr Value(int value) {
    return make_unique<ValueNode>(value);
}

ExpressionPtr Sum(ExpressionPtr left, ExpressionPtr right) {
    return make_unique<SumNode>(move(left), move(right));
}

ExpressionPtr Product(ExpressionPtr left, ExpressionPtr right) {
    return make_unique<ProductNode>(move(left), move(right));
}

// Функция для проверки равенства строк
bool check_equal(string value1, string value2) {
    return value1 == value2;
}

string Print(const Expression* e) {
    if (!e) {
        return "Null expression provided";
    }
    stringstream output;
    output << e->ToString() << " = " << e->Evaluate();
    return output.str();
}

// Тесты
void Test() {
    ExpressionPtr e1 = Product(Value(2), Sum(Value(3), Value(4)));
    if (!check_equal(Print(e1.get()), "(2)*((3)+(4)) = 14")) {
        cout << "Error: " << Print(e1.get()) << " != (2)*((3)+(4)) = 14" << endl;
    }

    ExpressionPtr e2 = Sum(move(e1), Value(5));
    if (!check_equal(Print(e2.get()), "((2)*((3)+(4)))+(5) = 19")) {
        cout << "Error: " << Print(e2.get()) << " != ((2)*((3)+(4)))+(5) = 19" << endl;
    }

    if (!check_equal(Print(e1.get()), "Null expression provided")) {
        cout << "Error: " << Print(e1.get()) << " != Null expression provided" << endl;
    }
}

int main() {
    Test();
    std::cout << "All tests passed!" << std::endl;
    return 0;
}

